using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using Microarea.TaskBuilderNet.Core.EasyBuilder;
using Microarea.TaskBuilderNet.Core.NameSolver;
using ICSharpCode.NRefactory;

using System.Diagnostics;
using ICSharpCode.NRefactory.CSharp;
using Microarea.TaskBuilderNet.Interfaces;

namespace Microarea.TaskBuilderNet.Core.EasyBuilder
{
	public static class EnumsHelper
	{
		//------------------------------------------------------------------
		public static Object GetAttribute(Type attrType)
		{
			Assembly currentAsm = typeof(EnumsDeclarator).Assembly;
			Object[] o = currentAsm.GetCustomAttributes(attrType, false);
			if (o.Length == 1)
				return o[0];
			throw new ApplicationException(string.Format("Attribute {0} not found in assembly {1}", attrType.ToString(), currentAsm.FullName));
		}

		//------------------------------------------------------------------
		public static void GenerateEasyBuilderEnumsDllIfNecessary()
		{
            BasePathFinder basePathFinderRef = BasePathFinder.BasePathFinderInstance;

			String enumsDllPath = Path.Combine(
                                    Path.Combine(basePathFinderRef.GetEasyStudioCustomizationsPath(), NameSolverStrings.ReferencedAssemblies),
                                    Microarea.TaskBuilderNet.Interfaces.NameSolverStrings.EasyStudioDllFileName
                                    );

            bool enumsDllToBeGenerated = false;
			String enumsDllFolderPath = Path.GetDirectoryName(enumsDllPath);

			try
			{
				//Se non esiste la cartella allora la creo e ritorno che anche la DLL deve essere generata.
				if (!Directory.Exists(enumsDllFolderPath))
				{
					Directory.CreateDirectory(enumsDllFolderPath);
					enumsDllToBeGenerated = true;
				}
			}
			catch (Exception exc)
			{
				Debug.WriteLine(exc.ToString());
				//AfxGetDiagnostic().Add(exc.ToString(), CDiagnostic.Error);
				return;
			}

			//Se il file non esiste allora devo generarlo
			FileInfo enumsDllFileInfo = new FileInfo(enumsDllPath);
			if (!enumsDllToBeGenerated && !enumsDllFileInfo.Exists)
				enumsDllToBeGenerated = true;

			//Altrimenti devo rigenerarlo se e solo se la data di invalidazione della cache
			//e` successiva alla data di creazione della dll.
			//La data della cache viene modificata anche in fase di installazione da
			//ClickOnceDeployer per cui si risolve il problema del confronto della versione e dell' installazione
			//successiva di verticali TaskBuilder C++.
			if (
				!enumsDllToBeGenerated &&
				enumsDllFileInfo.LastWriteTime < basePathFinderRef.InstallationVer.CDate
				)
				enumsDllToBeGenerated = true;

			if (!enumsDllToBeGenerated)
				return;

			EnumsDeclarator ed = new EnumsDeclarator();
			NamespaceDeclaration enumsCodeNamespace = new NamespaceDeclaration(Microarea.TaskBuilderNet.Interfaces.NameSolverStrings.EnumsNamespace);
			ed.GenerateEnumsCodeDom(enumsCodeNamespace);

			CompilerParameters parameters = new CompilerParameters();
			parameters.IncludeDebugInformation = false;
			parameters.GenerateInMemory = false;
			parameters.OutputAssembly = enumsDllPath;
			parameters.CompilerOptions = "/optimize";

			//Uso CSharpCodeProvider, tanto devo solo produrre una dll e non del codice
			//sorgente che verrà visualizzato da dentro le personalizzazionei di EB
			Dictionary<String, String> compilerOptions = new Dictionary<String, String>();
			compilerOptions.Add("CompilerVersion", "v4.0");
			
			CompilerResults res = null;
			try
			{
				using (CodeDomProvider compiler = new Microsoft.CSharp.CSharpCodeProvider(compilerOptions))
				using (StringWriter sw = new StringWriter())
				{

					Version version = typeof(BasePathFinder).Assembly.GetName().Version;
					String newVersion = String.Format(
								"{0}.{1}.{2}.*",
								version.Major,
								version.Minor,
								version.Build
								);

					//Aggiungo l'intestazione al file autogenerato e tutti gli attributi di assembly
					sw.WriteLine("// This file has been automatically generated by Microarea EasyBuilder");
					sw.WriteLine("// Copyright © {0} Microarea S.p.A.  All rights reserved.", DateTime.Now.Year);
					sw.WriteLine();
					sw.WriteLine("[assembly: System.Reflection.AssemblyCompany(\"{0}\")]", ((AssemblyCompanyAttribute)GetAttribute(typeof(AssemblyCompanyAttribute))).Company);
					sw.WriteLine("[assembly: System.Reflection.AssemblyProduct(\"EasyStudio Enums for TaskBuilder.Net\")]");
					sw.WriteLine("[assembly: System.Reflection.AssemblyVersion(\"{0}\")]", newVersion);
					sw.WriteLine("[assembly: System.Reflection.AssemblyDescription(\"EasyStudio generated assembly file\")]");
					sw.WriteLine();

					AstFacilities.GenerateCodeFromNamespaceDeclaration(enumsCodeNamespace, sw);
#if DEBUG
					//in debug produco anche il file su disco.
					String sourceFile = Path.ChangeExtension(enumsDllPath, "cs");
					StreamWriter streamWriter = new StreamWriter(sourceFile);
					streamWriter.Write(sw.ToString());
					streamWriter.Close();
#endif
					res = compiler.CompileAssemblyFromSource(parameters, sw.ToString());
				}
			}
			catch (NotImplementedException exc)
			{
				Debug.WriteLine(exc.ToString());
				//AfxGetDiagnostic().Add(exc.ToString(), CDiagnostic.Error);
			}

			if (res != null && res.Errors.Count > 0)
			{
				Debug.WriteLine("Errors building enums class");

				//for each (CompilerError compilerError in res.Errors)
				//    AfxGetDiagnostic().Add(compilerError.ToString(), CDiagnostic.Error);
			}
		}
	}
}

