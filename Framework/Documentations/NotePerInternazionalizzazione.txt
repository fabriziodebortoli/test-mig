
Il presente documento è da intendersi come riferimento per abilitare gli oggetti programmativi di TaskBuilder al supporto per 
l'internazionalizzazione.

La strategia di localizzazione (ossia traduzione in altra lingua) degli oggetti programmativi si basa sulla ricerca 
in un file XML della stringa originaria da localizzare e la sua successiva sostituzione, prima dell'effettivo utilizzo, con
il corrispondente valore della lingua target.

Ogni principale oggetto di TaskBuider può essere localizzato applicando le metodologie descritte nel presente documento.
Di seguito vengono elencati i possibili oggetti da localizzare unitamente alla procedura da seguire per la 
loro abilitazione alla localizzazione.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					STRINGHE PRESENTI NEI SORGENTI
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Questa categoria corrisponde alle stringhe un tempo memorizzate nei file ST, adesso cablate direttamente nel codice.
Per rendere localizzabile una stringa è necessario racchiuderla all'interno della macro _TB().

ESEMPIO:

AfxMessageBox(_TB("Ciao Mondo")):

Se la stringa prevede dei parametri stile cwsprintf, questi devono essere numerati secondo l’esempio:

cwsprintf(_TB(“Stringa con {0-%d} parametro o con {1-%d}?”), 1, 2)

La numerazione parte da 0 e serve per permettere al traduttore di modificare l’ordine di utilizzo dei parametri; 
lo stile è stato mutuato da C# per quanto riguarda la numerazione del parametro, continua a seguire quello della 
printf C per quanto riguarda i formattatori dopo il carattere %. Ovviamente per formattare la stringa non è possibile
utilizzare metodi nativi dell'ambiente di sviluppo (ad esempio la Format di CString), ma va utilizzata 
la funzione di TaskBuilder cwsprintf.


E' molto importante che la macro _TB racchiuda il literal di tipo stringa, e non una sua rappresentazione indiretta 
(ad esempio utilizzando macro) in quanto in questo caso non sarebbe raggiungibile dal tool di traduzione.

_TB("Stringa")		// corretto

#define s "Stringa"
_TB(s)			// errato


CString s = "Stringa"
_TB(s)			// errato

Se la stringa è ripetuta più volte e si presenta la necessità di centralizzarla, occorre utilizzare la seguente mappa:



----------------------------------------------------------------------------------------------------------------
<NomeFileDiStringhe>.H

BEGIN_TB_STRING_MAP(<NomeClasseDiStringhe>)
	TB_STANDARD(BMP_EXTENSION, "bmp")			//stringa non soggetta a traduzione	
	TB_LOCALIZED(BMP_FILE_NAME, "File di tipo Bitmap")	//stringa da localizzare
	TB_LOCALIZED(BMP_FILE_NAME_WITH_PARAMS, "File di tipo Bitmap: {0-%s}")	//stringa da localizzare
END_TB_STRING_MAP()

----------------------------------------------------------------------------------------------------------------
<NomeDelFileCheUtilizzaLaStringa>.cpp

AfxMessageBox( <NomeClasseDiStringhe>::BMP_FILE_NAME() );		// ricordarsi le parentesi per la chiamata a funzione 
AfxMessageBox( cwsprintf (						// (non si tratta di vere e proprie variabili)
				<NomeClasseDiStringhe>::BMP_FILE_NAME(),
				"File1." + <NomeClasseDiStringhe>::BMP_EXTENSION() 
			) );	



Non sono in ogni caso da utilizzare le #define:

#define stringa _TB("Stringa")	//errato: la procedura di localizzazione non è in grado di trovare la stringa


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					Maschere di documenti
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Se la maschera utilizza gli oggetti standard di TaskBuider o suoi derivati (CAbstractFormView, CTabDialog, ecc.) 
non occorre alcun intervento.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					Finestre di dialogo derivate da CDialog
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Occorre derivare da CLocalizableDialog invece che da CDialog

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					Property pages e property sheets
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Occorre derivare da CLocalizablePropertyPage e CLocalizablePropertySheet invece che da CPropertyPage e CPropertySheet 

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					Frame
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Se la frame è di tipo CMDIChildWnd, derivare da CLocalizableFrame; questo abilita la localizzazione delle seguenti risorse 
di frame:
	- tooltip della toolbar
	- messaggio nella messagebar
	- titolo di default della finestra

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					Menu
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Se il menu è inserito nel contesto di un template di documento, non occorre alcun intervento: è la classe template 
di TaskBuilder che opera la localizzazione.

Se il menu viene gestito "manualmente" (ossia, viene istanziato un oggetto CMenu e viene chiamata la LoadMenu)
allora occorre instanziare un oggetto CLocalizableMenu in luogo di CMenu.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					Documento XML
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Affinché il documento XML sia localizzabile occorre che, per ogni nodo il cui testo si deve localizzare, sia specificato 
l'attributo <localizable="true">. Opzionalmente è possibile specificare anche il dizionario che opera la traduzione,
aggiungendo l'attributo <dictionary="application.module.dictionaryName">. Il nome del dizionario corrisponde normalmente
al mome del file XML da localizzare, ma potrebbe darsi il caso in cui un file XML (slave) utilizzi stringhe di testo
presenti anche in altri file xml (master), pure essi localizzabili. In tal caso, la localizzazione delle stringhe 
del file slave deve essere effettuata utilizzando il dizionario del file master (per evitare difformità di 
traduzione).

Se è necessario localizzare il testo di un attributo invece che di un nodo, l'attributo deve obbligatoriamente 
chiamarsi 'localize' (es. <name localize="questa deve essere tradotta"/>)

Per aprire un file XML localizzabile è necessario utilizzare la classe CLocalizableXMLDocument in luogo di
CXMLDocumentObject (il metodo LoadXMLFile carica il file da localizzare, lo localizza con una trasformazione
XSLT e restituisce il DOM del file così localizzato).
In fase di salvataggio viene operata la trasformazione inversa, in modo da ripristinare i valori originari.
Se vengono apportate modifiche al testo dei nodi "tradotti", pertanto, queste vengono perse in fase di salvataggio. 

Per evitare questo, laddove normalmente si invoca il metodo SetText della classe CXMLNode occorre invece utilizzare 
il metodo SetLocalizableText, previo cast del puntatore da CXMLNode a CLocalizableXMLNode.
Analogamente, se invece di ottenere il valore corrente del nodo si desidera conoscerne quello ante traduzione, occorre
utilizzare il metodo GetLocalizableText (sempre operando il cast).

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					Report Woorm
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Per i report di Woorm occorre effettuare la seguente distinzione:
- la stringa fa parte di un oggetto grafico di Woorm (tabella, campo, ...): per questa tipologia di oggetti non occorre alcun intervento
- la stringa fa parte di una espressione: in questo caso, se la stringa va localizzata occorre utilizzare la funzione interna
  localize(); "Inizio" diventa pertanto: localize("Inizio")

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Tutti gli oggetti localizzabili sono definiti nel file "LocalizableObjs.h, .cpp"  del progetto TBGenlib
