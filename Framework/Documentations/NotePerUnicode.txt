Il presente documento è applicabile a tutti i progetti MFC in cui è necessario abilitare il supporto UNICODE.

Lo standard Unicode utilizza due byte per la memorizzazione di ogni carattere, in contrapposizione allo standard ASCII 
che ne utilizza solamente uno. Questo permette di avere a disposizione un set di caratteri più ampio, al prezzo 
di un raddoppio dello spazio di memoria occupato.

Per abilitare un progetto Visual C++ alla compilazione UNICODE 
(mantenendo però la compatibilità ANSI pregressa) occorre creare una nuova configurazione di progetto da utilizzare 
per la compilazione UNICODE. 
La nuova configurazione si può creare a partire da una esistente accedendo alle proprietà di progetto,
quindi premendo il pulsante "Configuration Manager..." ed accedendo alla maschera per la creazione di nuove configurazioni.

Partendo dalle configurazioni esistenti (Debug e Release) andranno qiondi create, rispettivamente, le configurazioni
UnicodeDebug e UnicodeRelease: 
- UnicodeDebug eredita le proprietà iniziali da Debug (menu a tendina "Copy settings from...")
- UnicodeRelease eredita le proprietà iniziali da Release (menu a tendina "Copy settings from...")

Una volta creata la nuova configurazione, occorre apportarvi le seguenti modifiche (a livello di proprietà di progetto):
1.	specificare Use UNICODE character set nella voce Character Set della sezione General.
2.	se si tratta di un eseguibile, specificare l’entry point "wWinMainCRTStartup" nella sezione Linker/Advanced
3.	Impostare le proprietà ‘Output Directory’ e ‘Intermediate Directory’ al valore UnicodeDebug e UnicodeRelease 
	rispettivamente per le due configurazioni di debug e release

A questo punto occorre modificare il codice ovunque siano utilizzate variabili stringa o 
funzioni che manipolano stringhe non compatibili con UNICODE. 

- il tipo base per il carattere unicode è wchar_t (omologo di char); il tipo wchar_t non va però usato
	esplicitamente (altrimenti verrebbe meno la compilabilità della configurazione ANSI). Va invece utilizzato il tipo 
	TCHAR che, se la compilazione è ANSI (#ifndef _UNICODE) si traduce in un char, altrimenti (#ifdef _UNICODE)
	si traduce in un wchar_t
	
-	le costanti di tipo stringa UNICODE hanno il prefisso L; ad esempio: 
				L"Questa è una stringa";
	Esiste la macro "jolly" che converte un literal di tipo stringa nel corrispondente ASCII o UNICODE a seconda delle esigenze:
				_T("Questa è una stringa");
	
- le corrispondenti macro associate ad array di caratteri (LPSTR, LPCSTR, ecc) vanno sostituite con le corrispondenti macro 
	"jolly" (che diventano UNICODE solo se necessario: #ifdef _UNICODE) LPTSTR, LPCTSTR, ecc.
	
- per ogni funzione che manipola stringhe ASCII, esiste la corrispondente funzione che manipola stringhe UNICODE (DA NON UTILIZZARE)
	e la corrispondente macro "jolly" (da utilizzare in luogo della funzione ASCII), che ragiona in UNICODE solo se necessario: #ifdef _UNICODE.
	Per conoscere la funzione "jolly" associata alla funzione ASCII consultare la documentazione di quest'ultima.
	
- le funzioni che manipolano stringhe ricevendo come parametro in ingresso il numero di byte da manipolare vanno
	modificate, in quanto se la stringa è UNICODE, il numero di byte da considerare è doppio. Ad es.:
	
	CFile aFile;
	aFile.Open(...);
	char [] szBuff = "Ciao";
	
	aFile.Write(szBuff, strlen(szBuff);
	aFile.Close();
	
	DIVENTA:
	
	CFile aFile;
	aFile.Open(...);
	TCHAR [] szBuff = _T("Ciao");		//uso di THCAR e della macro _T()
	
	aFile.Write(szBuff, _tcslen(szBuff) * sizeof(TCHAR);	//uso di _tcslen e determinazione del numero di byte	
	aFile.Close();
	
-	Esistono eccezioni alla regola; ad es.:
	-	la classe CRuntimeClass non supporta UNICODE 
	-	la funzione di sistema operativo GetProcAddress non supporta UNICODE 
	-	la macro di ambiente _FILE__ definisce una stringa non UNICODE
	-	...
	
	Se l'eccezione non costituisce un problema (non è necessario avvalersi di un set di caratteri esteso)
	è possibile utilizzare le macro A2T per effettuare la conversione da ASCII a stringa "jolly" (ASCII o
	UNICODE a seconda delle esigenze); l'utilizzo di questa macro deve essere preceduto dall'istruzione USES_CONVERSION.
	